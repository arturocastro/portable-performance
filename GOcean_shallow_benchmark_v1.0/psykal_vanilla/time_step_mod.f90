module time_step_mod
  use kind_params_mod
  use field_mod, only: copy_field
  use topology_mod, only: M, N
  implicit none

contains

  subroutine invoke_time_step(cufld, cvfld, ufld, unew, uold, &
                              vfld, vnew, vold, &
                              pfld, pnew, pold, &
                              hfld, zfld, tdt)
    use compute_cu_mod,   only: compute_cu_code
    use compute_cv_mod,   only: compute_cv_code
    use compute_z_mod,    only: compute_z_code
    use compute_h_mod,    only: compute_h_code
    use compute_unew_mod, only: compute_unew_code
    use compute_vnew_mod, only: compute_vnew_code
    use compute_pnew_mod, only: compute_pnew_code
    use time_smooth_mod,  only: time_smooth_code
    implicit none
    real(wp), dimension(:,:), intent(inout) :: cufld, cvfld
    real(wp), dimension(:,:), intent(inout) :: unew, vnew, pnew
    real(wp), dimension(:,:), intent(inout) :: hfld, zfld, pfld, &
                                               ufld, vfld
    !> \todo Do we need these 'old' arrays as args or are they
    !! local workspace really?
    real(wp), dimension(:,:), intent(inout) :: uold, vold, pold
    real(wp),                 intent(in) :: tdt
    ! Locals
    integer :: I, J

    !============================================
    ! COMPUTE CAPITAL U, CAPITAL V, Z AND H

    !call invoke_compute_fluxes(CU, CV, z, h, P, U, V)

    !CALL invoke_compute_cu(CU, P, U)
    ! M/N obtained from topology look-up
    do J= 1, N, 1
       do I = 2, M+1, 1

          call compute_cu_code(i, j, cufld, pfld, ufld)
       end do
    end do

    !CALL invoke_compute_cv(CV, P, V)
    do J= 2, N+1, 1
       do I= 1, M, 1

          call compute_cv_code(i, j, cvfld, pfld, vfld)
       end do
    end do

    !CALL invoke_compute_z(z, P, U, V)
    do J= 2, N+1, 1
       do I= 2, M+1, 1

          call compute_z_code(i, j, zfld, pfld, ufld, vfld)
       end do
    end do

    !CALL invoke_compute_h(h, P, U, V)
    DO J= 1, N, 1
       DO I= 1, M, 1

          CALL compute_h_code(i, j, hfld, pfld, ufld, vfld)
       END DO
    END DO

    !============================================
    ! PERIODIC CONTINUATION

    !CALL invoke_apply_bcs_uvtf(cufld, cvfld, hfld, Zfld)
    !call invoke(periodic_bc(cu), periodic_bc(cv), ....)

    !call invoke_apply_bcs_cu(ufield)
    ! Ultimately, this can be generated by PSyclone but in the
    ! absence of that we implement it manually here...
    ! First col = last col
    cufld(1,    1:N) = cufld(M+1,  1:N)
    ! Last row = first row
    cufld(1:M+1,N+1) = cufld(1:M+1,1)

    !call invoke_apply_bcs_ct(tfield)
    ! Last col = first col
    hfld(M+1,1:N) = hfld(1,  1:N)
    ! Last row = first row
    hfld(1:M+1,N+1) = hfld(1:M+1,1)

    !call invoke_apply_bcs_cv(vfield)
    cvfld(1:M,1    ) = cvfld(1:M,N+1)
    ! Last col = first col
    cvfld(M+1,1:N+1) = cvfld(1,  1:N+1)

    !call invoke_apply_bcs_cf(ffield)
    ! First col = last col
    zfld(1,    2:N+1) = zfld(M+1,  2:N+1)
    ! First row = last row
    zfld(1:M+1,1)     = zfld(1:M+1,N+1)

    !============================================
    ! COMPUTE NEW VALUES U,V AND P

    !CALL manual_invoke_compute_unew(unew, uold,  z, cv, h, tdt)
    DO J=1, N, 1
       DO I= 2, M+1, 1

          CALL compute_unew_code(i, j, unew, uold, &
                                 zfld, cvfld, hfld, tdt)

       END DO
    END DO
    !CALL manual_invoke_compute_vnew(vnew, vold,  z, cu, h, tdt)
    DO J= 2, N+1, 1
       DO I= 1, M, 1

          CALL compute_vnew_code(i, j, vnew, vold, &
                                 zfld, cufld, hfld, tdt)
       END DO
    END DO
    !CALL manual_invoke_compute_pnew(pnew, pold, cu, cv,    tdt)
    DO J= 1, N, 1
       DO I= 1, M, 1

          CALL compute_pnew_code(i, j, pnew, pold, &
                                 cufld, cvfld, tdt)
       END DO
    END DO

    !============================================
    ! PERIODIC CONTINUATION
    !CALL invoke_apply_bcs_uvt(UNEW, VNEW, PNEW)

    !call invoke_apply_bcs_cu(unew)
    ! Ultimately, this can be generated by PSyclone but in the
    ! absence of that we implement it manually here...
    ! First col = last col
    unew(1,    1:N) = unew(M+1,  1:N)
    ! Last row = first row
    unew(1:M+1,N+1) = unew(1:M+1,1)

    !call invoke_apply_bcs_cv(vnew)
    ! First row = last row
    vnew(1:M,1    ) = vnew(1:M,N+1)
    ! Last col = first col
    vnew(M+1,1:N+1) = vnew(1,  1:N+1)

    !call invoke_apply_bcs_ct(pnew)
    ! Last col = first col
    pnew(M+1,1:N) = pnew(1,  1:N)
    ! Last row = first row
    pnew(1:M+1,N+1) = pnew(1:M+1,1)

    !============================================
    ! The time-smoothing is applied to a field at *every* grid point
    
    ! Loop over 'columns'
    DO J=1,N+1 !idim2
      DO I=1,M+1 !idim1
        CALL time_smooth_code(i,j,ufld,unew,uold)
      END DO
    END DO

    ! Loop over 'columns'
    DO J=1,N+1 ! idim2
      DO I=1,M+1 ! idim1
         CALL time_smooth_code(i,j,vfld,vnew,vold)
      END DO
    END DO

    ! Loop over 'columns'
    DO J=1,N+1 ! idim2
      DO I=1,M+1 ! idim1
         CALL time_smooth_code(i,j,pfld,pnew,pold)
      END DO
    END DO

    !============================================
    ! Update for next step
    CALL copy_field(UNEW, Ufld)
    CALL copy_field(VNEW, Vfld)
    CALL copy_field(PNEW, Pfld)

  end subroutine invoke_time_step

end module time_step_mod
