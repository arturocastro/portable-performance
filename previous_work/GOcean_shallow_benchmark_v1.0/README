
This code is version 1.0 of the GOcean version of 'shallow' - a
benchmark shallow-water code originally written by Paul
Swartztrauber of NCAR.

* BEFORE COMPILING AND RUNNING PLEASE READ THIS DOCUMENT, *
* ESPECIALLY POINT 5 REGARDING COMPILATION.               *

The directory named 'original' contains pretty much the original
version of the code as received by this project. The directory named
psykal_vanilla contains a 'PSyKAl' version of the code where PSyKAl stands
for Parallel System, Kernel and Algorithm layers. In this PSyKAl
version all computation is performed in point-wise kernels (the bottom
layer). The algorithm (top) layer specifies operations on the whole
solution arrays. The middle layer (prefixed by invoke_'s) glues the
Algorithm and Kernel layers together. Ultimately this middle layer
will be generated by the PSyclone system but that's another story.

We would like to obtain sequential and intra-node (OpenMP, OpenACC,
... based) performance results for the two versions of the kernel (we
are not looking at MPI parallel at the moment).

What we are ultimately interested in is a) whether there is a
performance cost in using the PSyKAl approach compared with the
original code, and if so, why and how much, and b) what optimisations
improve performance, whether these differ across architectures (and
possibly problem sizes), and whether these optimisations can be
replicated in the PSyclone generation system.

Performance results will be shared between the different parties and a
joint paper published on the findings.
 
1: the original (single-file) version

We are particularly interested in a "how fast can you go" solution for
this version, where you are allowed to change what you like as long as
you get the same results! The aggressive optimisations and resultant
performance improvements are exactly what we would like to see. If it
so happens that different optimisations give better performance at
different resolutions then please feel free to implement different
versions (if you have time of course!).

2: the PSyKAl (multi-file) version

The idea of the PSyKAl (multi-file) version is also to optimise as
much as possible, i.e. "as fast as you can go", but to limit any
optimisations to the PSy layer. In practice, for this code, this means
optimisations are limited to within the invoke_time_step()
routine. Note, getting the compiler to inline via structural changes
is also interesting to us as it informs us how we might need to write
kernels in the future. Note, you are also allowed to copy a kernel
subroutine into the PSy layer module if the compiler does not inline,
or if this produces a performance improvement over compiler inlining.

3: Problem sizes

The default size provided is 256. This is set in the 'namelist' file.
We would like results from the following "base" problem sizes:
256, 512, 1024

The following (small) optional sizes are also of interest,
primarily for *CPU's* as the cache performance can improve for
smaller problems:
64, 128

The following (large) optional sizes are also of interest,
primarily for GPU's, to ensure there is enough work to keep the GPU
busy:
2048, 4096

Whilst we have provided suggested problem sizes that are powers of 2
it may be the case that the relative performance differs when
non-powers-of-two sizes are compared with powers-of-2 sizes and you
might want to look into these if you have time. (Note that the arrays
used in the code actually have extents one greater than the supplied
domain size. For instance, if you specify a domain of 128x128 then
the arrays will be allocated as (129,129).)

4: A note on timing and timing calls

The only timing we actually require is the time per step which is
obtained from the timer around the timestep loop. In the provided code
this is reported to stdout as the 'Average/repeat' time. Other timers
might be useful to see how the different parts of the code scale but
should not get in the way of optimisations. As an example, if you
fused two loops together, each with their own timer then the obvious
thing to do would be to replace the two timers with a single timer
(appropriately named) around the fused loop.

Jitter (noise) in the timing results can be a problem, particularly
for the smaller test cases. We therefore recommend that the number of
time-steps in the namelist file is set to a value that produces
run-times for which jitter is not significant.  For reproducible
results you must ensure that the process is being pinned to a
particular core.  We recommend repeating the run a number of times
(~5-10) and taking the time of the quickest run as being 'the answer.'

5: Technical details (compilation etc.)

All of the codes depend upon a configuration file and timing routines
that are in the 'common' directory.  Before attempting to compile
anything, change to the common directory and in it create a file named
'Makefile.include' by either copying or linking to one of the supplied
Makefile.include.<compiler_name> files. You will almost certainly have
to edit the settings in this file to match your local set-up.  With
this done, typing 'make' in either the 'original' or 'psykal_vanilla'
directories should produce an executable.

If you have any questions about this benchmark then please feel free
to contact either Andrew Porter or Rupert Ford who can be reached at
firstname dot lastname at stfc.ac.uk.
